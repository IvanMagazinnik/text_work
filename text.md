# Введение
Тестирование - Один из главных этапов разработки программного обеспечения, необходимо для решения двух задач:
* Продемонстрировать работодателю и заказчику что программа работает и работает верно, в соответствии с поставленной задачей и заявленными целями.
* Обнаружить ситуации, когда приложение работает некорректно и выявить причину этого дефекта.

Разделяют два вида тестирования: Ручное и автоматическое.
Ручное тестирование производится специальным человеком - тестировщиком, без использования специализированных программных средств и предназначено для выявления ошибок в работе приложения путём моделирования действия пользователя. Основной и главной проблемой ручного тестирования является человеческий фактор, а как следствие низкая скорость работы, высокая ресурсоемкость и увеличение ошибок с течением времени. Поэтому в настоящее время ручное тестирование применяется только для интеграционного и системного тестирования. Основное же модульное тестирование производится автоматически.   
Автоматизация тестирования - использование специализированных приложений или модулей для осуществления или помощи в проведении определённых тестов. Плюсы автоматического тестирования: Быстрота, автоматические отчёты, выполнение в фоне.   
В связи с переходом от ручного тестирования к автоматическому, возникает широкий класс задач связанный с автоматической проверкой корректности работы графического пользовательского интерфейса (Gui). Популярность такого вида тестирования объясняется двумя факторами: во-первых, приложение тестируется тем же способом, которым его будет использовать человек, во-вторых, можно тестировать приложение, не имея при этом доступа к исходному коду.  
# Постановка задачи
Основной проблемой автоматического тестирования Gui является отсутствие единых стандартов программных интерфейсов (Api) для взаимодействия тестовых фреймворков с приложением. Основные подходы к решению этой проблемы:
* Координатный метод поиска объектов.
* Распознавание образов
* Подход, использующий механизмы реализации специальных
возможностей (accessibility) и особенности реализации некоторых Gui фреймворков.    

Первые два из вышеописанных подходов предполагают лишь обнаружение объектов в приложении, но не взаимодействие с ними. И лишь подход, использующий accessibility технологии позволяет управлять объектами приложения. Однако такое взаимодействие будет далеко от реального обращения пользователя с программой.
Вследствие чего возникает задача эмулирования пользовательских действий фреймворком тестирования.    
Рассмотрим два основных способа взаимодействия пользователя с программой:
* Управление объектами с помощью мыши
* Ввод данных или использование специальных сочетаний клавиш с помощью клавиатуры.   

Рассмотрим способы и средства эмулирования пользовательских действий в существующих фреймворках автоматического тестирования Gui.

# Существующие решения

## Automa
Инструмент под Windows позволяющий автоматизировать пользовательские сценарии работы с GUI. Позволяет работать с простыми командами такие как: запуск приложения, ввод текста, клик по объекту.
Минусы:
* Отсутствие кроссплатформенности
* Закрытый исходный код
* Приложение платное

## Pyautogui
Бесплатная кроссплатформенная библиотека для языка python позволяющая программно управлять событиями мыши и клавиатуры.
Под Linux данная библиотека взаимодействует с Api предоставляемым X Windows System. А под Windows использует win32api подключаемое из библиотек языка с/с++
Минусы:
* Возможность управлять только окном приложения, но не объектами внутри него.
* Из-за того, что библиотека использует модули из языка c++ изменение её, в случае если это необходимо будет сильно затруднено.

## Pywinauto
<!-- Нужно найти более детальное и красивое описание библиотеки -->
Бесплатная библиотека для языка python состоящая из набора модулей предназначенных для автоматического гибкого взаимодействия с Microsoft Windows Gui.
Эмулирование пользовательских действий в pywinauto  
реализовано с помощью win32api - библиотеки  Windows содержащая набор классов, процедур, функций структур и констант, которые используют программы для создания и работы с окнами в ОС Windows.   

Минусы:
* отсутствие кроссплатформенности.    

В связи, с чем было принято решение о портирование некоторых модулей данной библиотеки, а в дальнейшем и всей библиотеки под системы Linux и Mac os. Так как аналогичных кроссплатформенных библиотек, обладающих таким широким спектром решаемых задач, и удобным интерфейсом под данные системы не существует, а хотелось бы иметь один тестовый фреймворк под все системы.

<!-- Нужной найти список приложений аналогов / конкурентов под Windows / Linux -->
## TBD

# X Window System
X Window System оконная система, обеспечивающая стандартные инструменты и протоколы для построения графического интерфейса пользователя. Используется в UNIX-подобных ОС.

X Window System обеспечивает базовые функции графической среды: отрисовку и перемещение окон на экране, взаимодействие с устройствами ввода, такими как, например, мышь и клавиатура. X Window System не определяет деталей интерфейса пользователя — этим занимаются менеджеры окон, которых разработано множество. По этой причине внешний вид программ в среде X Window System может очень сильно различаться в зависимости от возможностей и настроек конкретного оконного менеджера.   

Работа с клавиатурой в X Window:  когда пользователь нажимает (отпускает) клавишу, сервер получает соответствующий сигнал, который преобразуется в событие и отправляется в очередь программы, имеющей фокус ввода (input focus).   
Так как клавиатура обычно у машины одна, она разделяется между всеми одновременно выполняющимися программами. Сигнал, поступающий от устройства доступен лишь одной из них, обычно, той, которой принадлежит активное окно. Под этим и стоит понимать, что программа и её окно имеют фокус ввода. Последний может переходить от окна к окну и от программы к программе.

Работа с мышью в X Window: Общение программы с мышью похоже на работу с клавиатурой, X-сервер получает сигналы от устройства, преобразует их в события и помещает последние в очередь программы. Однако есть существенная разница. Если события от клавиатуры передаются лишь программе, окно которой имеет фокус ввода, то события от мыши могут передаваться, любой задаче, окно (окна) которой присутствуют на экране.

# Python Xlib
Python-xlib библиотека для языка python предоставляющая удобное api для работы с X Window System клиентом.
Рассмотрим основные используемые функции и классы этой библиотеки:    
`Display()`: создает объекта класса Display который устанавливает соединение клиента с X сервером.
`fake_input(display, event_type, x, y)`: функция, принимающая текущее соединение клиента с Х сервером, и структуру типа event_type - тип события. Интересующее нас событие XKeyEvent

Когда пользователь нажимает клавишу клавиатуры, программа получает событие KeyPress. Сервер также может послать событие KeyRelease, когда клавиша отпускается, но это справедливо не для всех типов компьютеров.   
Оба этих события сопровождаются структурой типа XKeyEvent. Ее поле keycode содержит код нажатой клавиши, а поле state - состояние клавиш-модификаторов и кнопок мыши. Модификаторами называются такие клавиши, как Shift, Ctrl, Caps Lock. Кроме этого, X предусматривает наличие дополнительных модификаторов, которые обозначаются Mod1, ..., Mod5. Каждой нажатой клавише-модификатору и кнопке мыши соответствует флаг в поле state.   
Коды, передаваемые через поле keycode структуры XKeyEvent, однозначно идентифицируют клавиши. Их конкретные значения зависят от типа машины и клавиатуры. Эти коды можно назвать физическими. Чтобы обеспечить переносимость программ, сервер устанавливает соответствие между физическими кодами клавиш, которые могут меняться от компьютера к компьютеру, и целочисленными константами - логическими кодами (символами).    

`keycode_to_keysym`: позволяет по коду keycode получить соответствующий ему символ с номером index. Если index равен 0, то полученный символ соответствует просто нажатой клавише. Если index равен 1, то возвращается символ,соответствующий ситуации, когда клавиша нажата одновременно с Shift.    

`keysym_to_keycode`: Осуществялет обратное преобразование.

# Проделанная работа
<!-- Скорее всего этот пункт стоит переименовать вопрос как -->
## Работа с мышью
Задача: имея готовый модуль работы с мышью под Windows изменить его чтобы он работал и под Linux при этом сохранить старый Api и добавить новые кросплатформенные возможности.

На основе имеющейся функции `perform_click_input()`, которая в заданной точке экрана осуществляла одно переданное параметром действие с мышью, была создана аналогичная функция использующая Python-xlib функцию fake_input.

Важным пунктом в реализации этой функции была обработка случая swapped button, когда кнопки мыши в системе переназначены, что может быть удобно в определенной ситуации. Для этого приложение опрашивает X сервер и получает карту соответствия кодов и кнопок мыши с помощью функции xlib `get_pointer_mapping()`.

На основе функции `perform_click_input()` были созданы дополнительные кроссплатформенные функции предоставляющие более удобный Api для работы с библиотекой:
* `click(button, coords)`: Осуществляет клик указанной кнопкой button в заданной позиции coords
* `double_click(button, coords)`: Двойной клик указанной кнопкой button в заданной позиции coords
* `wheel_click`: Клик средней кнопкой мыши в указанной позиции coords
* `right_click(coords)`: Щелчок правой кнопкой мыши в заданной позиции
* `move(coords)`: перемещение курсора мыши из заданной позиции в положение coords
* `press(button, coords)`: Щелчок и удержание заданной кнопки button мыши в указанном положении coords
* `release(button, coords)`: Отпускание указанной удерживаемой кнопки button в заданной позиции coords
* `scroll(coords, wheel_dist)`: Прокрутка колесика мыши в заданной позиции coords на указанную дистанцию wheel_dist


## Работа с клавиатурой
В отличии от модуля для работы с мышью в случае с клавиатурой было принято решения не объединять код для Linux и Windows платформы в один файл, из-за большого объема получившегося кода, а также из-за разницы в константах описывающих кнопки клавиатуры под эти платформы.   
Таким образом на основе существующего файла SendKeysCtypes.py был реализован модуль SendKeys.py поддерживающий тот же Api что и исходный модуль.    
Реализованный класс `KeyAction` хранит событие клавиатуры которое должно быть исполнено с примененными к нему модификаторами control, shift, alt.    
Реализованные функции:
* `to_keycode(key)`: С помощью функции `keysym_to_keycode()` возвращает keycode для указанного символа.
* `_key_modifiers(...)`: Функция проверяет был ли применен к символу один из модификаторов control, shift, alt и производит нажатие этих клавиш.
* `Run()` Функция класса KeyAction исполняет описанное в классе событие с помощью функции fake_input
* `parse_keys(string, with_spases, with_tabs, with_newlines)`: Преобразует заданную строку специального вида в набор событий KeyAction с учетом модификаторов игнорирования пробелов, табов и переносов строк.
* `SendKeys(keys, pause, with_spases, with_tabs, with_newlines)`: функция по заданной строке keys совершает указанные события нажатий клавиш клавиатуры.

## Модуль clipboard
Модуль предназначен для обмена информацией с буфером обмена, является расширением существующего модуля clipboard.py под Windows.
Ключевой особенностью реализации данного модуля была проблема в том что X server не работает с буфером обмена, эта задача отдается либо оконным менеджерам (DE) либо сторонним приложениям расширениям для X server. Под Linux такими приложениями являются например xsel распространяемый по лицензии mit и xclip издаваемый по лицензии bsd. Под Osx существует встроенное приложение pbcopy.
Было принято поддерживать все три приложения в модуле. Xsel как обязательное к установке приложение под Linux и xclip как альтернативная возможность по желанию.
Общение с этими приложениями из модуля идет посредством функции `subprocess()`
Реализованные функции:
* `set_up_clipboard()`: Ищет в системе указанные выше приложения для работы с буфером обмена.
* `get_data()`: Возвращает информацию из буфера обмена приведенную к формату utf-8
* `set_data(text)`: Записывает в буфер обмена значение находящееся в переменной text, без параметров очищает буфер обмена.

## Тесты
На все три выше описанных модуля были написаны специальные unit тесты для проверки корректности работы этих модулей, и дополнительной поддержке при работе в будущем. Тесты были реализованны с помощью библиотеки unittests - специального фреймворка для тестирования python модулей.   
Для проведения тестов были взяты приложения из специальных наборов примеров Qt c++, распространяемых по лицензии BSD.
(Тут стоит разместить скриншоты этих приложений)

## Подключение сервиса непрерывной интеграции
### TBD

